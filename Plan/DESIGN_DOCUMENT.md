````markdown
# 🎮 ShootingGame7 設計思想書

**【最終更新】2025-10-02 | Version 1.1**

---

## 🚨 AIへの指示（最優先で読むこと）

このドキュメントは、プロジェクト全体の「憲法」である。
**コードを書く前に、必ず以下のチェックリストを確認せよ。**

違反したコードは、たとえ動作しても**即座に却下される。**

---

## 📋 絶対遵守事項（チェックリスト）

コードを書く前、ファイルを変更する前に、**この全項目を確認せよ。**

### ✅ ECSアーキテクチャ

- [ ] システムは、自身の専門外のコンポーネントを知らないか？
- [ ] コンポーネントのコンストラクタは `new Component({ key: value })` 形式か？
- [ ] システム間の通信は、Worldイベント経由か？

### ✅ イベント駆動

- [ ] **【危険】** イベントハンドラ内で、エンティティの存在確認を行ったか？
  - エンティティは既に削除されている可能性がある
- [ ] イベントオブジェクトは、エンティティIDのみを含むか？
  - 参照やコンポーネントを含めてはならない

### ✅ ファイル操作

- [ ] 変更対象ファイルの役割を、このドキュメントの「ディレクトリ構造」で確認したか？
- [ ] 新規ファイルは、正しいディレクトリに配置されているか？

### ✅ AI協働プロトコル

- [ ] 仮説→検証→計画→実行のプロセスを守っているか？
- [ ] **全ファイルの分析が完了する前に、コードを書き始めていないか？**

---

## 🎯 プロジェクトの核心（30秒で理解）

**目標:**  
ベクタースキャン風ワイヤーフレーム描画による「**演算美**」の実現

**開発デバイス:**  
Samsung Galaxy Fold6 DEXモード

**制約:**  
BlitzIDE（Webベース）、**開発者コンソール使用不可**

**戦略:**  
ECS設計により、将来の描画ライブラリ換装（PixiJS/Three.js）に備える

---

## 🏗️ アーキテクチャ詳細

### ECS（エンティティ・コンポーネント・システム）の原則

**思想：「関心の分離」を徹底する。**

**コンポーネント:**  
データを保持する「部品」  
❌ ロジックを持ってはならない

**エンティティ:**  
コンポーネントをまとめる「入れ物」  
❌ 独自のメソッドを持ってはならない

**システム:**  
ロジックを実行する「専門家」  
❌ 専門外のコンポーネントを参照してはならない

---

### コンストラクタのオブジェクト形式

コンポーネントを `new` する際は、引数として単一のオブジェクトを渡すこと。

✅ **Good: 拡張性が高く、可読性が良い**
```javascript
const pos = new Position({ x: 100, y: 200 });
const vel = new Velocity({ vx: 5, vy: 0 });
```

❌ **Bad: 引数の順序を覚える必要があり、将来の拡張が困難**
```javascript
const pos = new Position(100, 200);  // x, y どっち？
const vel = new Velocity(5, 0);      // vx, vy が不明瞭
```

---

### イベント駆動の原則

システム間の通信は、**Worldを介したイベント**で行う。各システムは、自身の関心のあるイベントのみを購読し、他のシステムの存在を意識しない。

🚨 **【重要】** イベントハンドラの注意事項：

#### 1. エンティティの生存を保証されない

イベントを処理する前に、必ずエンティティの存在確認を行うこと。

✅ **Good: 存在確認を行う**
```javascript
onCollision(event) {
  const entity = this.world.getEntity(event.entityId);
  if (!entity) return;  // 既に削除済みの可能性
  
  const health = this.world.getComponent(event.entityId, Health);
  health.value -= 10;
}
```

❌ **Bad: 存在確認なし**
```javascript
onCollision(event) {
  const health = this.world.getComponent(event.entityId, Health);
  health.value -= 10;  // エンティティが既に削除されていたらクラッシュ
}
```

#### 2. イベントオブジェクトはIDと事実のみ

参照やコンポーネント等のデータを含めず、間接的な結合を避けること。

✅ **Good: エンティティIDのみ**
```javascript
world.emit('collision', { 
  entityId: 42, 
  targetId: 99,
  type: 'meteor-bullet'
});
```

❌ **Bad: 参照を含める**
```javascript
world.emit('collision', { 
  entity: entityObject,
  target: targetObject
});
```

---

## 📂 ディレクトリ構造と役割

**【注意】** 実際のファイル配置は `/game/Plan/DIRECTORY_STRUCTURE.md` を参照すること。
以下は、各ディレクトリが**持つべき役割**の定義である。

### / (ルート)

**役割:**  
Reactアプリケーションのエントリーポイント。

**配置すべきもの:**
- `package.json`: プロジェクトの依存関係
- `*.tsx`, `*.css`: Reactコンポーネントとスタイルシート（UI/ガワ）

**制約:**
- `index.html`は直接編集不可（Nextjs/Reactの仕様）
- Canvasのサイズ等は `GameCanvas.tsx` で管理する

### /game

**役割:**  
プロジェクトの心臓部。ECSのゲームロジック全体を格納する。

### /game/components

**役割:**  
コンポーネントを格納する。

**配置すべきもの:**  
データとその初期値を持つclass定義のみ。ロジックを含めてはならない。

### /game/systems

**役割:**  
システムを格納する。

**配置すべきもの:**  
特定のコンポーネントを持つエンティティに対するロジックを定義する。

### /game/core

**役割:**  
ECSフレームワークの中核となるファイルを格納する。

**配置すべきもの:**  
- `World.js`: ECSのコア
- `main.js`: ゲームループ
- `entityFactory.js`: エンティティ生成ファクトリ

### /game/blueprints

**役割:**  
エンティティの設計図（ブループリント）を格納する。**（開発予定）**

**配置すべきもの:**  
各ファイルは、特定のエンティティ（例: meteor）がどのコンポーネントをどのような初期値で持つかを定義するデータモジュール。

**目的:**  
エンティティの定義をコード（entityFactory.js）からデータに分離し、保守性と拡張性を高める（データ駆動設計）。

### /game/debug

**役割:**  
デバッグ表示、開発支援機能などを格納する。**（開発時専用）**

**配置すべきもの:**  
リリースビルドでは除外されるべきコード。

### /game/debug/systems

**役割:**  
デバッグ専用のシステムを格納。

**配置すべきもの:**  
- `DebugSystem.js`: HUD表示
- `OffscreenCleanupSystem.js`: 開発時のみ有効な機能

これらのシステムは、`/game/systems/` とは分離し、リリース時に除外しやすくする。

### /game/Plan

**役割:**  
AI依存開発におけるポリシーや開発計画を記した書類。**（開発時専用）**

**配置すべきもの:**  
- `DESIGN_DOCUMENT.md`: この設計思想書

---

**【注意】** ファイルを削除・変更する際は、必ず上記の役割を確認すること。役割が不明なファイルは「負債」である可能性が高い。

---

## 🤖 AI協働開発ワークフロー（厳守）

このプロジェクトでは、以下の**4ステップ**を厳密に守る。
**ステップを飛ばした提案は、即座に却下される。**

これは、AIの能力（高速なコード生成、定型作業の自動化）を最大限に活用しつつ、その弱点（文脈理解の限界、ハルシネーション）によるリスクを管理するための、最重要プロトコルである。

### 1️⃣ 仮説立案（Hypothesis）

- 変更の目的から、影響が及ぶファイル群について**知的な仮説**をAIが立てる
- ❌ 闇雲なコード作成は行わない

### 2️⃣ 検証（Verification）

- 仮説を検証するため、関連ファイルを**一つずつ**AIが要求し分析する
- ❌ 可能性を網羅し慎重に分析を重ねる

### 3️⃣ 計画の確定（Plan Finalization）

- 全ファイルの分析が完了し、仮説が**実証された後**、初めて最終コードを生成する
- ❌ 分析途中でコードを書き始めない

### 4️⃣ 実行（Execution）

- 確定した計画を、**動作保証するコードを残し少しずつ**機械的に適用する
- ❌ 必ず動くコードを残しつつデバッグ表示する

---

このワークフローは、断片的な施工による破綻を防ぎ、AIの「知的だが視野が狭い」という特性を補い、プロジェクト全体の安定性を確保するためのものである。

---

## 🎨 描画システムの段階的進化

### フェーズ1（現在）

**目的:**  
ゲームのコアロジック（移動、回転、当たり判定、AI）の高速なプロトタイピングに集中する。

**使用技術:**  
Canvas 2D Context

**描画:**  
RenderSystemが `fillRect` や `beginPath` で「仮の姿」を描画する。

### フェーズ2（将来）

**目的:**  
「演算美」の実現と、大量のエンティティを処理するパフォーマンスの確保。

**候補技術:**  
PixiJS, Three.js

**移行戦略:**  
ECSの設計により、RenderSystemのみを新しいライブラリで書き直すだけで移行可能。

---

## 🔧 デバッグ制約への対処

**制約:**  
BlitzIDEでは開発者コンソールが使用できない。

**対処法:**

- `/game/debug/systems/DebugSystem.js` で画面内HUD表示を実装
- `/game/debug/DebugConfig.js` でデバッグ機能のON/OFF切り替えを管理

---

## 📝 用語集

**演算美:**  
大量の計算によって生み出される視覚的美しさ。ベクタースキャン風ワイヤーフレーム、大量パーティクルによる表現を指す。

**ベクタースキャン風:**  
古典的なアーケードゲーム（Asteroids等）のような、線描画による表現。

**関心の分離:**  
データ（コンポーネント）とロジック（システム）を完全に分離する設計思想。ECSアーキテクチャの根幹をなす原則。

---

## 🗂️ ファイル・関数管理ルール

**目的:**  
デバッグやリファクタリング時の混乱による構造破壊を防ぐ。

**ルール:**

1. 新しい機能を追加する際は、まずこのDESIGN_DOCUMENT.mdを参照し、アーキテクチャに沿っているか確認する
2. ファイルや関数を削除・変更する際は、その役割がこのドキュメントにどう記載されているかを確認する
3. 役割が不明なファイル・関数は「負債」である可能性が高い。リファクタリングの対象とする
4. このドキュメント自体も、大きな設計変更があった場合は随時更新し、常に最新の状態を保つ

---
````
