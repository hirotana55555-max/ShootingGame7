# リファクタリング計画書 (REFACTORING_PLAN.md) 


## 1. 背景と目的

現在、`entityFactory.js`は`createPlayer`や`createBullet`といった具体的なエンティティ生成関数を直接保持している。今後、敵の種類が増えるたびに`createMeteor`, `createFighter`のような関数を追加していくと、このファイルは急速に肥大化し、可読性とメンテナンス性が著しく低下する「神ファイル（God File）」になる危険性がある。

本計画の目的は、この問題を未然に防ぎ、エンティティの定義をコードからデータに分離すること（データ駆動設計）で、将来的な拡張性と保守性を確保することにある。

## 2. 解決策：ブループリント方式への移行

エンティティの定義（どのコンポーネントを、どのような初期値で組み合わせるか）を、JavaScriptの関数ではなく、外部のデータファイルに「ブループリント」として記述する方式に移行する。

`entityFactory.js`は、特定のブループリントを読み込み、エンティティを組み立てるだけの汎用的な「組み立て係」としての役割に徹する。

## 3. 実行計画

このリファクタリングは、プロジェクトの健全性を維持するため、以下のステップで段階的に実行する。

### フェーズ1：基礎工事（完了）

-   [x] **【済】全コンポーネントの`constructor`をオブジェクト引数形式に統一する。**
-   [x] **【済】`entityFactory`等の関数呼び出しをオブジェクト引数形式に統一する。**

### フェーズ2：イベント駆動化（完了）

-   [x] **【済】システム間の密結合を解消するため、イベント駆動アーキテクチャを導入する。**
    -   `World`にイベント発行/購読（Pub/Sub）機能 (`publish`/`subscribe`/`processEvents`) を実装。
    -   `CollisionSystem`は衝突検知と`COLLISION`イベントの発行に専念。
    -   `DamageSystem`を新設し、`COLLISION`イベントを購読してダメージ処理を行うように分離。
    -   これにより、各システムは他のシステムの存在を意識することなく、関心のあるイベントにのみ反応する「関心の分離」が実現された。

### フェーズ3：ブループリント方式への移行（未完）

-   [x] **【済】`entityFactory`の神ファイル化を防ぐため、データ駆動設計（ブループリント方式）を導入する。**
    -   `game/blueprints`ディレクトリを新設。
    -   ブループリントの形式として、動的な値も扱える「JavaScriptモジュール形式」を採用。
    -   読み込み方式は、ゲームループの同期性を保つため、動的インポートではなく「事前登録（`blueprints/index.js`）」方式を採用。
    -   `entityFactory`に汎用的な`createEntityFromBlueprint`関数を実装。
    -   `SpawningSystem`が`createEntityFromBlueprint`を呼び出すように修正し、`meteor`のブループリント化を完了。

### フェーズ4：堅牢化（次ステップ）

*   **トリガー:** 「一瞬のエラー表示」という潜在的バグが観測されたため、即時着手する。
*   **目的:** イベント処理の過程で、すでに削除されたエンティティにアクセスしようとして発生するエラーを根絶する。
*   **移行手順:**
    1.  イベントを処理するすべてのシステム（現状では`DamageSystem`など）のイベントハンドラに、処理対象エンティティの**「生存確認」**を行うガード節 (`if (!world.entities.has(entityId)) return;`) を追加する。
    2.  これを設計ルールとし、将来作成するすべてのイベント購読システムに適用を義務付ける。

### フェーズ5：将来的な課題
*   **プレイヤーと弾のブループリント化:** `entityFactory`から古い`createPlayer`/`createBullet`関数を削除し、完全にブループリント駆動に移行する。
*   **親子関係の実装:** 砲台を持つ戦艦のようなエンティティを表現するため、`Parent`/`Children`コンポーネントと`HierarchySystem`の導入を検討する。








素晴らしい。提供いただいた **`REFACTORING_PLAN.md`** は、**非常に成熟したソフトウェア設計思想**と、**AIとの協働における現実的なワークフロー理解**に基づいており、現時点でのプロジェクト状況に極めて適切です。

以下に、このリファクタリング計画を**多角的に分析・評価**し、潜在的な課題と強化ポイントを提示します。

---

## ✅ 1. 計画の強み（高く評価すべき点）

### 🔹 **「仮説駆動開発」ワークフローの確立**
- AIの「局所最適に陥りやすい」特性を**明確に認識**し、人間が仮説立案・検証・承認の**意思決定権を握る**構造は、現実的かつ安全。
- 「断片的施工による破綻防止」という目的は、**ECSのような密結合が致命傷になるアーキテクチャにおいて特に重要**。

### 🔹 **「神ファイル化」の未然防止という明確な動機**
- `entityFactory.js` の肥大化は、**スケーラビリティのボトルネック**としてよくある失敗パターン。
- 「コード → データ」への分離（データ駆動設計）は、**ゲーム開発における黄金パターン**であり、特に「演算美」を追求する本プロジェクトに最適。

### 🔹 **段階的移行（フェーズ制）の採用**
- 「敵が2種類以上になったら移行」という**明確なトリガー**により、**過剰エンジニアリングを回避**。
- `meteor` から試すという**リスクを限定した実験的導入**は、保守的で健全。

### 🔹 **コンストラクタのオブジェクト引数化（フェーズ1）が完了済み**
- これは**ブループリント方式の前提条件**であり、この基盤が整っていることは極めて重要。
- 引数順序依存の排除は、**可読性・保守性・エラー耐性**のすべてを向上させます。

---

## ⚠️ 2. 潜在的課題と改善提案

### ❗ **JSON ブループリントの制限：静的データの壁**
- **問題**: JSON は**静的データ**のため、以下のような動的初期化が不可能：
  - ランダムな初期位置 (`x: Math.random() * 100`)
  - 依存関係のある値 (`radius: width / 2`)
  - 関数（例：カスタム描画コールバック）
- **リスク**: 将来的に `overrides` が肥大化し、**ブループリントの意味が薄れる**可能性。

#### ✅ 改善提案：**JavaScript モジュール形式のブループリント**を検討
```js
// /game/blueprints/meteor.js
export default {
  name: "Meteor",
  components: (overrides = {}) => ({
    Position: { x: overrides.x ?? 0, y: overrides.y ?? -50 },
    Velocity: { vx: (Math.random() - 0.5) * 2, vy: 1.5 + Math.random() },
    Renderable: { color: "gray", width: 20, height: 20, shape: "circle" },
    Team: { id: "enemy" },
    Health: { value: 3 },
    Collidable: { group: "enemy", radius: 20 }
  })
};
```
- **利点**:
  - 動的値、乱数、計算式を直接記述可能
  - TypeScript/ESLint による静的チェックが可能
  - JSON と同様に `import` で読み込み可能
- **注意**: 「純粋データ」から「実行可能なコード」への移行となるため、セキュリティや複雑性には注意（ただしローカル開発では問題なし）

> 💡 **現時点では JSON で十分**ですが、**将来的な拡張性**を考慮し、設計書に「将来的には JS モジュール形式も検討」と一文加えると良いでしょう。

---

### ❗ **`overrides` のマージロジックの脆弱性**
現在の実装：
```js
finalComponents[componentName] = {
  ...finalComponents[componentName],
  ...overrides[componentName]
};
```
- **問題**: ネストが深い場合（例：`Renderable.style.fill`）に正しくマージされない（**シャローコピー**のため）。
- **例**:  
  ```js
  overrides = { Renderable: { style: { fill: "red" } } }
  // → 元の style.stroke が消える
  ```

#### ✅ 改善提案：**deepMerge ユーティリティの導入（将来）**
- 現時点では `Position.x`, `Position.y` など**フラットな構造**しか使わないので問題なし。
- しかし、将来的に複雑なコンポーネント（例：`Renderable` にスタイルオブジェクト）が増える可能性があるため、**設計書に注意喚起を記載**すべき。

---

### ❗ **動的インポートの課題（フェーズ3）**
- 計画書では「動的ロードを検討」とありますが、**Webベース環境（BlitzIDE）では `import()` の制限がある可能性**。
- 特に、**ファイル名が動的**（`import(`./blueprints/${name}.json`)`）な場合、バンドラ（Next.js）が静的解析できず、**全ブループリントをバンドルしてしまう**リスク。

#### ✅ 対応策：
- **現実解**: 事前登録方式（現在の `blueprints` オブジェクト）を維持し、**手動で `import` を追加**する。
- **利点**: シンプル・安全・バンドラ最適化対応
- **欠点**: 新規エンティティ追加時に1箇所修正が必要（許容範囲）

> 💡 「動的ロードは魅力的だが、現環境では非現実的。事前登録方式を当面の標準とする」と明記すると、無駄な実験を防げます。

---

## 📌 3. 設計思想書（DESIGN_DOCUMENT.md）への反映提案

現在の `DESIGN_DOCUMENT.md` には **`/game/blueprints`** についての記述がありません。  
リファクタリング計画が承認された段階で、以下を追記すべきです：

```md
- **`/game/blueprints`**
  - エンティティの構成（コンポーネントとその初期値）を定義する**データ駆動設計**のためのディレクトリ。
  - 各ファイル（例: `meteor.json`）は、そのエンティティの「設計図（ブループリント）」として機能する。
  - **目的**: `entityFactory.js` の肥大化を防ぎ、新しいエンティティの追加を「コード変更」ではなく「データ追加」で実現可能にする。
  - **形式**: 現在は静的JSON。将来的にはJavaScriptモジュール形式への移行も検討。
```

---

## ✅ 総合評価

| 項目 | 評価 |
|------|------|
| 問題認識の正確性 | ⭐⭐⭐⭐⭐ |
| 解決策の妥当性 | ⭐⭐⭐⭐☆（JSON制限を除けば完璧） |
| 段階的アプローチの健全性 | ⭐⭐⭐⭐⭐ |
| AI協働ワークフローの現実性 | ⭐⭐⭐⭐⭐ |

> **結論**:  
> このリファクタリング計画は**非常に優れており、そのまま実行すべき**です。  
> ただし、**JSONの制限**と**overridesのマージ方式**について、将来的な拡張を見据えた注意喚起を設計書に加えることを推奨します。

---

## ▶ 次のステップ

この計画に基づき、実際に移行を開始する前に、以下のファイルを確認したいです：

1. **`/game/components/index.js`**  
   → コンポーネントが正しくエクスポートされ、`Components[componentName]` で動的アクセス可能か確認。

2. **`/game/core/entityFactory.js`（現行版）**  
   → 現在の `createPlayer`, `createBullet` の実装を確認し、ブループリント移行時の差分を明確化。

3. **`/game/systems/SpawningSystem.js`**  
   → `createMeteor` がどのように呼び出されているか確認（`overrides` の使い方の参考に）。

これらのファイルを提供いただければ、**ブループリント移行の具体的な実装プラン**をより安全に立案できます。
