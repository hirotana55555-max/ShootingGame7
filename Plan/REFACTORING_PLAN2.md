リファクタリング手順
（DeepSeekAI依存開発のリファクタリング相談25/10/01 13:35）

codemodなしでも実施可能な現実的な手順：

1. 現状ファイル分析と分類
2. 統一様式ルール策定
3. 設定ファイル雛形作成
4. 単一コンポーネント修正
5. 基本敵定義移行
6. エンティティ工場更新
7. 動作確認テスト実施
8. デバッグ表示強化
9. 残コンポーネント修正
10. 新しい敵追加テスト
11. AI状態管理実装
12. 階層構造対応
13. イベント処理拡張
14. 材質システム追加
15. 部位破壊実装
16. 全敵タイプ移行
17. 冗長コード削除
18. ドキュメント更新

主な変更点

· 分析とルール策定を明確化
· コンポーネント修正を分割（単一→残り）
· 安全な段階的アプローチ

codemodは効率的だが必須ではないという認識で一致しています。手動でも、1ファイルずつ確実に修正すれば安全に進められます。


補足

各工程は小さく分割され、必ず動作確認しながら進めます。既存コードを壊さず、新しい構造を追加する方針です。


コンポーネント変数オブジェクト指向化の段階

1. 段階3で開始
2. 段階4で本格化
3. 段階5で検証
4. 段階13で完了

補足

コンポーネント内変数のオブジェクト指向化は、段階3の敵定義移行時から自然に開始されます。具体的には、新しい設定ファイルからパラメータを読み込む過程で、既存のハードコードされた値を置き換えていきます。段階4の工場更新で本格化し、全敵タイプ移行（段階13）で完了します。



現状分析と統一様式の必要性

その通りです。段階3開始前に以下を実施すべきです。

優先実施事項

1. 全コンポーネントファイル分析
2. 変数様式統一ルール策定
3. 正常動作ファイルを基準化
4. 壊れたファイルを特定
5. 段階3用テンプレート作成
6. AI指示書を更新

変数様式統一ルール例

1. コンポーネントはクラス形式
2. プロパティはコンストラクタで
3. 初期値は明示的に定義
4. メソッドは持たない
5. 命名規則を統一
6. エクスポート形式を統一

分析と準備の重要性

1. 現状把握なしに修正不可
2. 正常状態をバックアップ
3. 壊れたファイルは隔離
4. 段階3で一貫性確保

まずは現状分析から開始し、統一ルールを確立してから段階3に進むべきです。


現状分析結果

コンポーネント様式の分類：

1. 数値直接渡し形式：
   · Health: new Health(3)
   · Lifetime: new Lifetime(0.8)
2. 文字列直接渡し形式：
   · Team: new Team('player')
3. 複合パラメータ形式：
   · Collidable: new Collidable('enemy', 20)
4. マーカーコンポーネント：
   · Controllable: new Controllable()
   · Bullet: new Bullet()

統一ルール提案

全コンポーネントをオブジェクト形式に統一：

```javascript
// 変換例：
new Health({ value: 3 })
new Lifetime({ duration: 0.8 })
new Team({ id: 'player' })
new Collidable({ group: 'enemy', radius: 20 })
new Controllable({}) // マーカーもオブジェクト形式で統一
new Bullet({})
```

# コンポーネント初期化方式の近代化リファクタリング (2025-10-01)

## 1. 目的

プロジェクト初期に定義されたコンポーネントの初期化方式（例: `new Health(3)`）は、引数の意味が不明瞭で、将来的な拡張性に乏しいという課題があった。
このリファクタリングの目的は、全てのコンポーネントのコンストラクタをオブジェクト形式（例: `new Health({ value: 3 })`）に統一することである。これにより、以下のメリットを享受する。

-   **可読性の向上:** 引数の意味がキー名によって明確になる (`{ value: 3 }` vs `3`)。
-   **保守性の向上:** 引数の順序を気にする必要がなくなり、将来的なプロパティ追加が容易になる。
-   **一貫性の確保:** プロジェクト全体のコードスタイルが統一され、新規開発者の学習コストが低下する。

## 2. リファクタリングプロセス

安全かつ確実に移行を進めるため、コンポーネントごとに以下の手順を繰り返す体系的なアプローチを採用した。

1.  **互換レイヤーの実装:** 対象コンポーネント（例: `Health.js`）を、旧形式と新形式の両方を受け付けるように改修。同時に、旧形式が使用された場合にその事実を記録するデバッグ機能を組み込む。

2.  **警告の可視化:** `DebugSystem.js` を改修し、旧形式の使用が検知された場合に、ファイル名や呼び出し内容をゲーム画面にリアルタイムで表示するようにした。

3.  **呼び出し元の修正:** 画面に表示された警告を元に、プロジェクト内のすべての旧形式呼び出し（主に `entityFactory.js` 内）を新形式に修正する。

4.  **最終確認:** 警告が表示されなくなったことを確認。念のため、IDEの全体検索機能（静的解析）も併用し、他のファイルに旧形式の呼び出しが残っていないことを確認した。

5.  **クリーンナップ:** 対象コンポーネントと `DebugSystem.js` から、手順1, 2で追加した互換レイヤーとデバッグ用コードを完全に削除し、コンポーネントを本来のシンプルな姿に戻す。

## 3. 成果

上記プロセスを経て、以下の全てのコンポーネントのコンストラクタをオブジェクト形式に統一することに成功した。

-   `Health`
-   `Team`
-   `Collidable`
-   `Lifetime`
-   `Controllable`
-   `Bullet`

これにより、プロジェクトのコンポーネントレイヤーは、設計思想書に沿った、より堅牢で保守性の高い状態に進化した。このリファクタリング手法は、今後の大規模なコード改修における優れたモデルケースとなるだろう。
