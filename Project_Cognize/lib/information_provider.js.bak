const { exec, execSync } = require('child_process');
const fs = require('fs');
const path = require('path');

// ===== ãƒ—ãƒ©ã‚¤ãƒ™ãƒ¼ãƒˆé–¢æ•°ç¾¤ (ã“ã®ãƒ•ã‚¡ã‚¤ãƒ«å†…ã§ã®ã¿ä½¿ç”¨) =====

function _detectLanguage(filePath) {
    const ext = path.extname(filePath).toLowerCase();
    const languageMap = {
        '.js': 'javascript', '.jsx': 'jsx', '.ts': 'typescript', '.tsx': 'tsx',
        '.py': 'python', '.java': 'java', '.cpp': 'cpp', '.c': 'c', '.cs': 'csharp',
        '.rb': 'ruby', '.go': 'go', '.rs': 'rust', '.php': 'php', '.swift': 'swift',
        '.kt': 'kotlin', '.scala': 'scala'
    };
    return languageMap[ext] || 'plaintext';
}

function _isComponentFile(filePath, config) {
    const normalizedTarget = path.relative(config.PROJECT_ROOT, path.join(config.PROJECT_ROOT, filePath)).replace(/\\/g, '/');
    return normalizedTarget.startsWith('game/components/');
}

function _getRelevantSystemFiles(componentPath, config) {
    const componentName = path.basename(componentPath, path.extname(componentPath));
    const allSystemFiles = fs.readdirSync(config.SYSTEMS_DIR).filter(f => f.endsWith('.js') || f.endsWith('.ts'));
    console.log(`\nðŸ” ${componentName}ã‚’ä½¿ç”¨ã—ã¦ã„ã‚‹Systemã‚’æ¤œç´¢ä¸­...`);
    const relevantSystems = [];
    for (const systemFile of allSystemFiles) {
        const systemPath = path.resolve(config.SYSTEMS_DIR, systemFile);
        try {
            const systemCode = fs.readFileSync(systemPath, 'utf8');
            const patterns = [
                new RegExp(`getComponent\\(['"\`]${componentName}['"\`]\\)`, 'g'),
                new RegExp(`hasComponent\\(['"\`]${componentName}['"\`]\\)`, 'g'),
                new RegExp(`addComponent\\(['"\`]${componentName}['"\`]`, 'g'),
                new RegExp(`removeComponent\\(['"\`]${componentName}['"\`]`, 'g'),
                new RegExp(`import.*${componentName}.*from`, 'g'),
                new RegExp(`require\\(['"\`].*${componentName}['"\`]\\)`, 'g')
            ];
            if (patterns.some(pattern => pattern.test(systemCode))) {
                relevantSystems.push(systemFile);
                console.log(`   âœ“ ${systemFile} - ${componentName}ã‚’ä½¿ç”¨`);
            }
        } catch (e) {
            console.warn(`   âš ï¸  ${systemFile} - èª­ã¿è¾¼ã¿ã‚¨ãƒ©ãƒ¼: ${e.message}`);
        }
    }
    if (relevantSystems.length === 0) {
        console.warn(`   âš ï¸  è­¦å‘Š: ${componentName}ã‚’ä½¿ç”¨ã—ã¦ã„ã‚‹SystemãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“ã§ã—ãŸ`);
        return allSystemFiles;
    }
    console.log(`\nðŸŽ¯ ${relevantSystems.length}/${allSystemFiles.length}å€‹ã®Systemãƒ•ã‚¡ã‚¤ãƒ«ãŒé–¢é€£ã—ã¦ã„ã¾ã™\n`);
    return relevantSystems;
}

function _compressDeps(targetFile, isComponent, config) {
    const queryScript = path.resolve(config.SCRIPT_DIR, 'query_index.js');
    if (!fs.existsSync(queryScript)) return `DEPS_WARNING:file=${targetFile}|status=query_script_missing`;
    
    try {
        const rawOutput = execSync(`node "${queryScript}" deps "${targetFile}"`, { encoding: 'utf8', cwd: config.PROJECT_ROOT, timeout: config.DEPS_TIMEOUT });
        let dependencies = [], dependents = [];
        let currentSection = null;
        rawOutput.split('\n').forEach(line => {
            if (line.includes('ä½¿ç”¨ã—ã¦ã„ã‚‹ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«')) currentSection = 'deps';
            else if (line.includes('ä½¿ç”¨ã—ã¦ã„ã‚‹ãƒ•ã‚¡ã‚¤ãƒ«')) currentSection = 'used';
            const match = line.match(/^\s*-\s+(.+?)\s+\[(.+?)\]/);
            if (match) {
                if (currentSection === 'deps') dependencies.push(`${match[1]}[${match[2]}]`);
                else if (currentSection === 'used') dependents.push(match[1]);
            }
        });
        if (isComponent) {
            const relevantSystems = _getRelevantSystemFiles(targetFile, config);
            dependencies = [...new Set([...dependencies, ...relevantSystems.map(f => `game/systems/${f}[POTENTIAL_ECS_DEPENDENCY]`)])];
        }
        const compressed = `DEPS:target=${targetFile}|imports=${dependencies.join(',')}|used_by=${dependents.join(',')}`;
        console.log(`ðŸ“¦ ä¾å­˜é–¢ä¿‚åœ§ç¸®: ${rawOutput.length}æ–‡å­— â†’ ${compressed.length}æ–‡å­—`);
        return compressed;
    } catch (e) {
        return `DEPS_ERROR:file=${targetFile}|error=${e.message.substring(0, 100)}`;
    }
}

function _truncateTscOutput(output, targetFile, maxErrors = 20) {
  const normalizedTargetFile = targetFile.replace(/\\/g, '/');
  const lines = output.split('\n');
  const targetFileErrors = [], otherErrors = [];
  let currentError = null;
  for (const line of lines) {
    const errorMatch = line.match(/^(.+?)\(\d+,\d+\): error TS\d+:/);
    if (errorMatch) {
      const filePath = errorMatch[1].replace(/\\/g, '/');
      currentError = { file: filePath, lines: [line] };
      if (filePath === normalizedTargetFile) targetFileErrors.push(currentError);
      else otherErrors.push(currentError);
    } else if (currentError && line.trim() !== '') {
      currentError.lines.push(line);
    } else {
      currentError = null;
    }
  }
  let result = [];
  if (targetFileErrors.length > 0) {
    result.push(`### å¯¾è±¡ãƒ•ã‚¡ã‚¤ãƒ«ã®ã‚¨ãƒ©ãƒ¼ (${targetFileErrors.length}å€‹) ###`);
    targetFileErrors.forEach(err => result.push(...err.lines, ''));
  }
  if (otherErrors.length > 0 && result.length < maxErrors * 2) {
    const remainingSlots = maxErrors - targetFileErrors.length;
    const includedOthers = otherErrors.slice(0, remainingSlots);
    if (includedOthers.length > 0) {
        result.push(`\n### ãã®ä»–ã®ãƒ•ã‚¡ã‚¤ãƒ«ã®ã‚¨ãƒ©ãƒ¼ (${includedOthers.length}/${otherErrors.length}å€‹ã‚’è¡¨ç¤º) ###`);
        includedOthers.forEach(err => result.push(...err.lines, ''));
    }
    if (otherErrors.length > remainingSlots) result.push(`\n... (æ®‹ã‚Š${otherErrors.length - remainingSlots}å€‹ã®ã‚¨ãƒ©ãƒ¼ã¯çœç•¥)`);
  }
  return result.join('\n');
}

function _runTscCheck(targetFile, config) {
  return new Promise((resolve) => {
    console.log(`\nðŸ©º TypeScriptã®åž‹ãƒã‚§ãƒƒã‚¯ã‚’å®Ÿè¡Œä¸­ (tsc --noEmit)...`);
    exec('npx tsc --noEmit', { cwd: config.PROJECT_ROOT, timeout: config.TSC_TIMEOUT }, (error, stdout, stderr) => {
      if (error) {
        if (error.code === 'ENOENT') {
          resolve(`[TSC CHECK RESULT: SKIPPED]\nâš ï¸ tscã‚³ãƒžãƒ³ãƒ‰ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“ã€‚`);
        } else if (error.killed) {
          resolve(`[TSC CHECK RESULT: TIMEOUT]\nâš ï¸ TSCãƒã‚§ãƒƒã‚¯ãŒã‚¿ã‚¤ãƒ ã‚¢ã‚¦ãƒˆã—ã¾ã—ãŸã€‚`);
        } else {
          const output = stdout || stderr;
          const errorCount = (output.match(/error TS/g) || []).length;
          console.warn(`   âš ï¸  TSCãƒã‚§ãƒƒã‚¯ã§ ${errorCount}å€‹ ã®åž‹ã‚¨ãƒ©ãƒ¼ãŒæ¤œå‡ºã•ã‚Œã¾ã—ãŸã€‚`);
          const truncatedOutput = _truncateTscOutput(output, targetFile);
          resolve(`[TSC CHECK RESULT: FAILED]\nä»¥ä¸‹ã¯TypeScriptã‚³ãƒ³ãƒ‘ã‚¤ãƒ©ã‹ã‚‰ã®ã‚¨ãƒ©ãƒ¼å ±å‘Šã§ã™ (${errorCount}å€‹)ã€‚\n\`\`\`\n${truncatedOutput}\n\`\`\``);
        }
      } else {
        console.log(`   âœ… TSCãƒã‚§ãƒƒã‚¯å®Œäº†: åž‹ã‚¨ãƒ©ãƒ¼ã¯è¦‹ã¤ã‹ã‚Šã¾ã›ã‚“ã§ã—ãŸã€‚\n`);
        resolve(`[TSC CHECK RESULT: PASSED]\nTypeScriptã®åž‹ãƒã‚§ãƒƒã‚¯ã¯æˆåŠŸã—ã¾ã—ãŸã€‚`);
      }
    });
  });
}

// ===== å…¬é–‹ã‚¤ãƒ³ã‚¿ãƒ¼ãƒ•ã‚§ãƒ¼ã‚¹ =====

async function gatherAllInfo(targetFile, config) {
    const fullPath = targetFile; // main.jsã‹ã‚‰çµ¶å¯¾ãƒ‘ã‚¹ãŒæ¸¡ã•ã‚Œã‚‹
    if (!fs.existsSync(fullPath)) throw new Error(`å¯¾è±¡ãƒ•ã‚¡ã‚¤ãƒ«ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“: ${targetFile}`);

    const isComponent = _isComponentFile(targetFile, config);
    if (isComponent) console.log(`âœ¨ Componentãƒ•ã‚¡ã‚¤ãƒ«ã‚’æ¤œå‡º â†’ é–¢é€£Systemã‚’åˆ†æžã—ã¾ã™\n`);

    const sourceCode = fs.readFileSync(fullPath, 'utf8');
    console.log(`ðŸ“„ ã‚½ãƒ¼ã‚¹ã‚³ãƒ¼ãƒ‰èª­ã¿è¾¼ã¿å®Œäº†: ${targetFile}`);

    const compressedDeps = _compressDeps(targetFile, isComponent, config);

    let tscResult = '[TSC CHECK RESULT: NOT_APPLICABLE]';
    if (/\.(ts|tsx)$/.test(targetFile) && fs.existsSync(path.join(config.PROJECT_ROOT, 'tsconfig.json'))) {
        tscResult = await _runTscCheck(targetFile, config);
    }

    let relevantSystemCodes = [];
    if (isComponent) {
        const systemFiles = _getRelevantSystemFiles(targetFile, config);
        console.log(`ðŸ“š é–¢é€£Systemãƒ•ã‚¡ã‚¤ãƒ«ã®ã‚½ãƒ¼ã‚¹ã‚³ãƒ¼ãƒ‰ã‚’èª­ã¿è¾¼ã¿ä¸­...\n`);
        systemFiles.forEach(file => {
            const relativePath = path.relative(config.PROJECT_ROOT, path.resolve(config.SYSTEMS_DIR, file));
            const fullPath = path.resolve(config.SYSTEMS_DIR, file);
            try {
                const code = fs.readFileSync(fullPath, 'utf8');
                relevantSystemCodes.push(`[SYSTEM CODE: ${relativePath}]\n\`\`\`${_detectLanguage(file)}\n${code}\n\`\`\``);
            } catch (e) {
                relevantSystemCodes.push(`[SYSTEM LOAD ERROR: ${relativePath}]\n${e.message}`);
            }
        });
    }

    return {
        sourceCode,
        language: _detectLanguage(targetFile),
        isComponent,
        compressedDeps,
        tscResult,
        relevantSystemCodes,
    };
}

module.exports = { gatherAllInfo };
